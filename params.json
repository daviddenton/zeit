{"name":"Zeit","tagline":"Clock and task scheduler for node.js applications, providing extensive control of time and callback scheduling in prod and test code","body":"#zeit  [![Build Status](https://travis-ci.org/daviddenton/zeit.png?branch=master)](https://travis-ci.org/daviddenton/zeit)\r\n\r\nA node.js clock and scheduler, intended to take place of the global V8 object for manipulation of time and task scheduling which\r\nwould be handled with calls to ```set/clearTimeout``` and ```set/clearInterval```. Zeit ships with a set of controllable Stub clocks\r\n which can be used for the manipulation of time and scheduling in tests.\r\n\r\n###Why does this project exist?\r\nWriting testable code which involves the concept of time is hard work, since you are need to interact with the global \"system\" object in order to:\r\n1. Create Date object instances.\r\n2. Schedule callbacks to be executed at some point in the future.\r\n\r\nIn order to ensure that this behaviour is acceptably deterministic (and hence testable),\r\nwe need to be able to control both of these events. The Zeit library provides objects to abstract\r\n away the global-ness of these operations, which can be used in [node.js](http://nodejs.org/) application code to\r\n provide a more managed method.\r\n\r\nFor test code you can use the bundled Stub implementations to effectively control the time in\r\nyour tests, which removes the need for non-deterministic methods for asserting order and expected bevahiour, many of which rely on timeouts.\r\n\r\nZeit currently supports both the native [JavaScript Date](http://www.w3schools.com/js/js_obj_date.asp) API and the (IMHO) superior\r\n[Moment.js](http://momentjs.com/) API.\r\n\r\n###tl;dr Examples:\r\n\r\n1. Schedule a single execution of a callback for 10 seconds in the future.\r\n```javascript\r\nnew zeit.Scheduler(new zeit.DateClock())\r\n    .execute(function () {\r\n        return 'some happy value';\r\n    })\r\n    .after(10000)\r\n    .start();\r\n```\r\n\r\n2. Schedule a Q promise to execute 5 times at 30 second intervals, starting immediately.\r\n```javascript\r\nnew zeit.Scheduler(new zeit.MomentClock())\r\n    .execute(function () {\r\n        return q.resolve('some happy path resolving promise');\r\n    })\r\n    .exactly(5)\r\n    .atFixedIntervalOf(moment.duration(30000))\r\n    .start();\r\n```\r\n\r\n3. Schedule repeatedly to trigger a callback at 1 minute breaks (wait for completion) while\r\nexecuted less than 1000 times and no error is thrown by the callback. Starts immediately.\r\n```javascript\r\nnew zeit.Scheduler(new zeit.DateClock())\r\n    .execute(function () {\r\n        return 'some happy value';\r\n    })\r\n    .andRepeatAfter(60000)\r\n    .whilst(function(scheduleItemDetails) {\r\n        return scheduleItemDetails.invocationCount < 1000;\r\n    })\r\n    .until(function(err, result) {\r\n        return err;\r\n    })\r\n    .start();\r\n```\r\n\r\n###Installation\r\nVia npm, simply run: ```npm install zeit```\r\n\r\n###API details\r\nZeit requires that the same supported Date API is used consistently throughout calling code - use\r\nthe wrong type and you'll get an explicit error:\r\n- Native Date implementation - Dates are represented as native Date objects, and durations are passed/returned as an integer number of milliseconds.\r\n- Moment.js implementation - Dates are represented as Moment objects and durations are passed/returned as Duration objects.\r\n\r\n####Real clocks - zeit.DateClock / zeit.MomentClock\r\nAbstracts the creation of date objects (using ```now```),\r\nand wraps the native ```set/clearTimeout``` & ```set/clearInterval``` methods. Also provides some\r\nutility methods below, which are required by the Scheduler implementation:\r\n\r\n#####now() -> current date\r\nIn the format relative to the implementation (see above).\r\n\r\n#####timeIn(durationInMilliseconds) -> augmented date\r\nReturns the current date incremented by the passed duration.\r\n\r\n#####numberOfMillisecondsAsDuration(numberOfMilliseconds) -> duration\r\nIn the format relative to the implementation (see above).\r\n\r\n####Stub clocks - zeit.StubDateClock / zeit.StubMomentClock\r\nExtends the Real Clock API and provides a means to control the current time by setting it\r\ndirectly, or implicitly/explicitly ticking by a set duration. API as above, with the following methods:\r\n\r\n##### Constructor(currentDate, tickSize, implicitTickFlag)\r\nIf no values passed, the following defaults are used:\r\n- currentDate: Start of universal time (01-01-1970)\r\n- tickSize: 1 second\r\n- implicitTickFlag: false\r\n\r\n#####now(newCurrentDate) -> current date\r\nSets the current date if passed, and then returns the current date in the relative format. If\r\nimplicit ticking is activated, the time will be incremented automatically by the set ticksize.\r\n\r\n#####intervals() -> { native id -> timeout duration }\r\nReturn a Hash of currently scheduled timeout durations by their timeout id.\r\n\r\n#####timeouts() -> { native id -> timeout duration }\r\nReturn a Hash of currently scheduled interval durations by their timeout id.\r\n\r\n#####triggerAll() -> [ids of all triggered callbacks]\r\nTriggers all of the currently stored timeouts and intervals. After completion, reschedules intervals at the specified duration and discards timeouts.\r\n\r\n#####lastKnownTime() -> current date\r\nSame as ```now()```, but with no ticking.\r\n\r\n#####tickSize(tickSizeInMilliseconds) -> current tick size duration\r\nIf passed, sets the current ticksize.\r\n\r\n#####tick(newTickSizeInMilliseconds) -> new current (ticked) date\r\nIncrements the current date by the duration in milliseconds, or the current ticksize if not passed. Then returns the new current date.\r\n\r\n#####implicitTick(newImplicitTickFlag) -> current implicit tick flag\r\nIf passed, sets the current implicit tick flag.\r\n\r\n\r\n####Scheduler - zeit.Scheduler\r\nWraps the native scheduling of repeating and non-repeating callbacks or [Promises/A compliant](http://wiki.commonjs.org/wiki/Promises/A) promises, but also provides the API to provide pre and post\r\npredicates to prevent execution or rescheduling or to control the number of executions.\r\nConfiguration of the schedules follows the Builder pattern. The scheduler doesn't make a\r\ndistinction between repeating and one-off events, rather the usage of the API determines this\r\nbehaviour.\r\n\r\nSchedulers are [Event Emitters](http://nodejs.org/api/events.html) which emit the following\r\nlifecycle events for each schedule, with the latest schedule details as the message:\r\n- start\r\n- finish\r\n- error\r\nNote that callbacks/promises which throw exceptions (or rejected promises) emit Start & Error (no\r\nFinish event), and that throwing an exception does not cancel repeat scheduling (to stop\r\nrescheduling on an error, use the until() predicate when configuring the schedule).\r\n\r\n#####execute(callback/promise factory function) -> Schedule Item Builder\r\nInitiates the Builder pattern for configuring the schedule item. The passed function can be\r\neither a standard callback or return a Promises/A compliant promise object. Some of the examples\r\nbelow and the internal Zeit implementation use the [Q](http://npmjs.org/package/q) library.\r\n\r\n#####activeSchedule(scheduleId) -> schedule details\r\nReturns details of the schedule, including the configuration and stats such as the invocation count and last run time.\r\n\r\n#####cancel(scheduleId) -> schedule details\r\nCancels the schedule and returns the latest details for that schedule, if any.\r\n\r\n#####cancelAll() -> (scheduleId -> schedule details)\r\nCancels all schedules and returns a Hash of the schedules cancelled.\r\n\r\n####Schedule Item Builder (returned by execute() in Scheduler)\r\nProvides the methods to configure the schedule. Calling ```start()``` actually schedules the execution.\r\nFollows the Builder pattern, so most methods return ```this```.\r\n\r\n#####named(schedule name) -> schedule item builder\r\nSets the name of the schedule.\r\n\r\n#####after(durationInMilliseconds) -> schedule item builder\r\nSets the initial delay before the first execution (like ```setTimeout```).\r\n\r\n#####atFixedIntervalOf(durationInMilliseconds) -> schedule item builder\r\nSets the repeat at a fixed rate, regardless of how long the execution takes.\r\n\r\n#####andRepeatAfter(durationInMilliseconds) -> schedule item builder\r\nSets the repeat at a fixed interval after execution has completed (like a tail call to ```setTimeout```).\r\n\r\n#####exactly(numberOfExecutions) -> schedule item builder\r\nSets the maximum number of executions, which may be adjusted by pre and post predicates.\r\n\r\n#####once() -> schedule item builder\r\nSyntactic-sugar for ```exactly(1)```.\r\n\r\n#####whilst(-> boolean) -> schedule item builder\r\nSets a pre-execution predicate, which will cancel all rescheduling once it returns false.\r\n\r\n#####until((err, result) -> boolean) -> schedule item builder\r\nSets a post-execution predicate, which will cancel all rescheduling once it returns true. The\r\nlast execution error and result are passed to this predicate, so asserting on these values is possible.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}